# CS230

•	Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design? – The Gaming Room client was a small indie gaming studio looking to build a cross platform multiplayer gaming application. 

•	What did you do particularly well in developing this documentation? – I think overall I built out several well written epics and user stories. I also addressed several architectural concerns and potential build impediments. 

•	What about the process of working through a design document did you find helpful when developing the code? – I think having a feature paired with one or several user stories which then relayed into a larger epic set the stage for proper software architecture. I think having a well thought out plan before building is very important.

•	If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it? – I think I would do a better job of giving the client overview. I think I could be more descriptive on the client itself instead of focusing solely on the project.

•	How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing? – My point about user stories and epics speaks to this. Features should be implemented for the user. Behavior driven development is particularly useful when thinking about the user. The end user is sometimes even more important than the client or stakeholder. 

•	How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application? – I started to address this in the previous answer. Test driven and behavior driven development are particularly useful in cases like this. Behavior driven when initially building and once the product is live migrating to test driven. I think it’s also important to have business analytics gathering useful information on current market trends. This way software can be built around the current and future features end users are looking for.

